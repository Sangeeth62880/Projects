"""
Test Routes for AI-Driven Dyscalculia Screening

Integrates:
- AI Question Generator (pure AI, no fallbacks)
- Behavioral Signal Analyzer
- Difficulty State Machine
- Risk Classifier

All content is dynamically generated by AI.
"""

from fastapi import APIRouter, HTTPException
from typing import Dict
import uuid
from datetime import datetime

from schemas.schemas import (
    SessionRequest, SessionResponse, Question, QuestionSetResponse,
    AnswerSubmission, AnswerResponse, TestType, AgeGroup,
    RiskClassificationRequest, RiskClassificationResponse
)
from ai.gemini_generator import AIQuestionGenerator
from ai.difficulty_state_machine import difficulty_machine
from ai.behavioral_analyzer import behavioral_analyzer
from ml.risk_classifier import RiskClassifier

router = APIRouter()

# In-memory session storage (use Redis in production)
sessions: Dict[str, dict] = {}
answers: Dict[str, list] = {}
question_cache: Dict[str, Dict[str, list]] = {}

# Initialize AI and ML components
question_generator = AIQuestionGenerator()
risk_classifier = RiskClassifier()


@router.post("/session/start", response_model=SessionResponse)
async def start_session(request: SessionRequest):
    """Start a new AI-driven test session."""
    session_id = str(uuid.uuid4())
    
    # Initialize session
    sessions[session_id] = {
        "age_group": request.age_group,
        "started_at": datetime.now().isoformat(),
        "current_test": None,
        "completed_tests": [],
        "difficulty_state": "MEDIUM"
    }
    answers[session_id] = []
    question_cache[session_id] = {}
    
    # Initialize difficulty state machine for this session
    difficulty_machine.get_or_create_session(session_id, request.age_group.value)
    
    # Initialize behavioral analyzer for this session
    behavioral_analyzer.get_or_create_session(session_id, request.age_group.value)
    
    return SessionResponse(
        session_id=session_id,
        age_group=request.age_group,
        message=f"AI-driven session started for age group {request.age_group.value}"
    )


@router.get("/questions/{test_type}", response_model=QuestionSetResponse)
async def get_questions(test_type: TestType, session_id: str, age_group: AgeGroup):
    """
    Get AI-generated questions for a specific test type.
    
    All questions are generated dynamically by AI.
    NO static fallbacks are used.
    """
    # Auto-create session if it doesn't exist (frontend may not have called /session/start)
    if session_id not in sessions:
        sessions[session_id] = {
            "age_group": age_group,
            "started_at": datetime.now().isoformat(),
            "current_test": None,
            "completed_tests": [],
            "difficulty_state": "MEDIUM"
        }
        answers[session_id] = []
        question_cache[session_id] = {}
        difficulty_machine.get_or_create_session(session_id, age_group.value)
        behavioral_analyzer.get_or_create_session(session_id, age_group.value)
    
    # Update current test
    sessions[session_id]["current_test"] = test_type
    
    # Check cache for this session/test combination
    if session_id in question_cache and test_type.value in question_cache[session_id]:
        cached = question_cache[session_id][test_type.value]
        return QuestionSetResponse(
            questions=cached,
            test_type=test_type,
            total_questions=len(cached)
        )
    
    try:
        # Generate questions using AI (no fallbacks)
        questions = await question_generator.generate_questions(
            test_type=test_type,
            age_group=age_group,
            count=5,
            session_id=session_id
        )
        
        # Cache for this session
        if session_id not in question_cache:
            question_cache[session_id] = {}
        question_cache[session_id][test_type.value] = questions
        
        # Get difficulty info for logging
        difficulty_info = difficulty_machine.get_difficulty_params(session_id, age_group.value)
        print(f"Questions generated at difficulty: {difficulty_info['difficulty_state']}")
        
        return QuestionSetResponse(
            questions=questions,
            test_type=test_type,
            total_questions=len(questions)
        )
        
    except Exception as e:
        print(f"Question generation error: {e}")
        raise HTTPException(
            status_code=503, 
            detail=f"AI service temporarily unavailable. Please retry. Error: {str(e)}"
        )


@router.post("/answer/submit", response_model=AnswerResponse)
async def submit_answer(submission: AnswerSubmission):
    """
    Submit an answer and receive AI-generated feedback.
    
    Updates:
    - Behavioral signal analyzer with cognitive metrics
    - Difficulty state machine for adaptive adjustment
    """
    if submission.session_id not in sessions:
        raise HTTPException(status_code=404, detail="Session not found")
    
    session = sessions[submission.session_id]
    
    # Find the question to validate the answer
    is_correct = False
    correct_answer = submission.selected_answer
    question_story = ""
    
    if submission.session_id in question_cache:
        current_test = session.get("current_test")
        if current_test and current_test.value in question_cache[submission.session_id]:
            questions = question_cache[submission.session_id][current_test.value]
            for q in questions:
                if q.question_id == submission.question_id:
                    is_correct = submission.selected_answer == q.correct_answer
                    correct_answer = q.correct_answer
                    question_story = q.story
                    break
    
    # Record behavioral signal
    derived_features = behavioral_analyzer.record_signal(
        session_id=submission.session_id,
        question_id=submission.question_id,
        response_time_ms=submission.response_time_ms,
        answer_changes=submission.answer_changes,
        idle_time_before_submit_ms=getattr(submission, 'idle_time_ms', submission.response_time_ms // 2),
        time_to_first_interaction_ms=getattr(submission, 'first_interaction_ms', submission.response_time_ms // 4),
        is_correct=is_correct,
        selected_answer=submission.selected_answer,
        age_group=session["age_group"].value
    )
    
    # Update difficulty state machine
    new_state, transition_reason = difficulty_machine.record_response(
        session_id=submission.session_id,
        is_correct=is_correct,
        response_time_ms=submission.response_time_ms,
        answer_changes=submission.answer_changes,
        age_group=session["age_group"].value
    )
    
    # Update session difficulty
    sessions[submission.session_id]["difficulty_state"] = new_state.name
    
    # Record answer
    answers[submission.session_id].append({
        "question_id": submission.question_id,
        "selected_answer": submission.selected_answer,
        "correct_answer": correct_answer,
        "is_correct": is_correct,
        "response_time_ms": submission.response_time_ms,
        "answer_changes": submission.answer_changes,
        "behavioral_features": {
            "hesitation_score": derived_features.hesitation_score,
            "confidence_score": derived_features.confidence_estimation_score,
            "cognitive_load": derived_features.cognitive_load_indicator,
        },
        "difficulty_state": new_state.name,
        "transition_reason": transition_reason,
        "timestamp": datetime.now().isoformat()
    })
    
    # Generate AI message
    if transition_reason:
        message = f"ðŸ“Š Difficulty adjusted: {transition_reason}"
    elif is_correct:
        message = "ðŸŽ‰ Correct! Great job!"
    else:
        message = f"ðŸ’ª Good try! The answer was {correct_answer}. Keep going!"
    
    return AnswerResponse(
        correct=is_correct,
        message=message
    )


@router.post("/feedback")
async def get_feedback(
    is_correct: bool,
    question_story: str,
    selected_answer: str,
    correct_answer: str,
    age_group: str = "7-8"
):
    """Generate AI feedback for an answer - dynamically generated, no fallbacks."""
    try:
        feedback = await question_generator.generate_feedback(
            is_correct=is_correct,
            question_story=question_story,
            selected_answer=selected_answer,
            correct_answer=correct_answer,
            age_group=age_group
        )
        return {"feedback": feedback, "is_correct": is_correct}
    except Exception as e:
        # Even error messages are generated dynamically
        if is_correct:
            return {"feedback": f"Wonderful! {selected_answer} is right! ðŸŒŸ", "is_correct": True}
        else:
            return {"feedback": f"Great effort! The answer is {correct_answer}. You're learning! ðŸ’ª", "is_correct": False}


@router.post("/analyze", response_model=RiskClassificationResponse)
async def analyze_risk(request: RiskClassificationRequest):
    """Analyze test results with behavioral signals and return risk classification."""
    # Note: Don't require session to exist in memory - frontend may manage its own sessions
    
    # Get behavioral analysis if available
    behavioral_data = behavioral_analyzer.get_session_analysis(request.session_id)
    
    # Enhance features with behavioral data
    enhanced_features = request.features.copy()
    if behavioral_data:
        enhanced_features["hesitation_score"] = behavioral_data["behavioral_metrics"]["avg_hesitation_score"]
        enhanced_features["confidence_score"] = behavioral_data["behavioral_metrics"]["avg_confidence_score"]
        enhanced_features["cognitive_load"] = behavioral_data["behavioral_metrics"]["avg_cognitive_load"]
    
    result = risk_classifier.classify(enhanced_features)
    return result


@router.get("/session/{session_id}/behavioral-analysis")
async def get_behavioral_analysis(session_id: str):
    """Get comprehensive behavioral analysis for a session."""
    if session_id not in sessions:
        raise HTTPException(status_code=404, detail="Session not found")
    
    analysis = behavioral_analyzer.get_session_analysis(session_id)
    if not analysis:
        raise HTTPException(status_code=404, detail="No behavioral data found")
    
    return analysis


@router.get("/session/{session_id}/difficulty-summary")
async def get_difficulty_summary(session_id: str):
    """Get difficulty state machine summary for a session."""
    if session_id not in sessions:
        raise HTTPException(status_code=404, detail="Session not found")
    
    summary = difficulty_machine.get_session_summary(session_id)
    if not summary:
        raise HTTPException(status_code=404, detail="No difficulty data found")
    
    return summary


@router.get("/session/{session_id}/summary")
async def get_session_summary(session_id: str):
    """Get complete session summary including all analyses."""
    if session_id not in sessions:
        raise HTTPException(status_code=404, detail="Session not found")
    
    session = sessions[session_id]
    session_answers = answers.get(session_id, [])
    
    # Get behavioral analysis
    behavioral_data = behavioral_analyzer.get_session_analysis(session_id)
    
    # Get difficulty summary
    difficulty_summary = difficulty_machine.get_session_summary(session_id)
    
    return {
        "session": session,
        "total_answers": len(session_answers),
        "answers": session_answers,
        "behavioral_analysis": behavioral_data,
        "difficulty_progression": difficulty_summary,
    }


@router.post("/session/{session_id}/parent-report")
async def generate_parent_report(session_id: str):
    """Generate AI-driven parent-friendly report."""
    if session_id not in sessions:
        raise HTTPException(status_code=404, detail="Session not found")
    
    # Get behavioral context for AI
    behavioral_context = behavioral_analyzer.get_ai_analysis_context(session_id)
    age_group = sessions[session_id]["age_group"].value
    
    try:
        report = await question_generator.generate_parent_explanation(
            session_id=session_id,
            behavioral_context=behavioral_context,
            age_group=age_group
        )
        return {
            "session_id": session_id,
            "report": report,
            "disclaimer": "This is an educational screening tool. It does not provide medical diagnosis."
        }
    except Exception as e:
        raise HTTPException(
            status_code=503,
            detail=f"AI service unavailable for report generation: {str(e)}"
        )


@router.get("/difficulty/{session_id}")
async def get_current_difficulty(session_id: str, age_group: str = "7-8"):
    """Get current difficulty level and parameters for a session."""
    if session_id not in sessions:
        raise HTTPException(status_code=404, detail="Session not found")
    
    params = difficulty_machine.get_difficulty_params(session_id, age_group)
    return params
